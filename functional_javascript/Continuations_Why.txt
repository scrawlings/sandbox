Why Continuations?

First of all what does continuation passing style look like? By example: I've turned a highly recursive algorithm into something using continuation passing style: It's a recursive descent expression parser in JavaScript, it takes math expressions and reprints them with all the correct bracketing for associativity and precedence.

The heart of the technical challenge is not relying on functions to implicit return to the point of call, instead tell the function where it continues when it is complete. After you make your call (send a message) you never come back.

Simulate this by not using returns. Pass a function to call next, and calling that next function you can do in any current function. 

You start by calling your first function and giving it the function you want to call last. The trick is it can inject functions in between so long as it tells them what they call next.

To make life simple the first thing I did was make all the signatures the same, everything gets an accumulated result to pass forward (this is a key transformation to make use of tail recursion optimisations anyway), and also a function to call when everything is done.

Then, instead of calling functions and waiting for their return values so that I can use them as inputs into subsequent functions, I provide the subsequent functions as continuations. I don't bother with return values at all, no more return statements.

So Why?

One of the most compelling reasons sadly isn't relevant to Java or JavaScript, in languages with Tail Recursion Optimisation this method lets TRO work so that it becomes as efficient in memory as a simple looping. (Sadly, without TRO if using function calls to pass messages it makes stack overflow more likely in Java or JavaScript or Scala etcâ€¦)

But even without TRO it's a mechanical process to turn this into a loop rather than recursive algorithm.

In a functional programming sense, it has allowed me to eliminate mutation. Nothing is consuming the original list of tokens, no more shifts mutating the token stream: implicit thread safety.

I've used function calls to pass control, but the actual call is made by a higher order function which allows me to add my own error checking, or turn it into a deferred function call to UI responsiveness, or to use some other message passing technique.

Some of the most scalable parallel systems abstractions only offer message calls without returns, (to avoid implicit synchronisation). By eliminating returns you transform your algorithm into something that can readily expressed in highly scalable distributed systems.

Learning to think in terms of one way message calls can be a powerful tool in your object oriented programming tool kit. It makes really clear the idea that a function call is sending a message to an object.

Broaden your mind. You learn to appreciate function returns as a power option, but not an unavoidable. It helps you see the implicit return of functions as language design choice and not an eternal truth.

Because it's more fun than sudoku most days.
